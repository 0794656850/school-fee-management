{% extends "base.html" %}
{% block title %}AI Assistant - {{ APP_TITLE }}{% endblock %}
{% block page_title %}AI Assistant{% endblock %}

{% block content %}
{# Always render the assistant. If no API key, backend uses heuristic mode. #}
<div class="grid grid-cols-1 md:grid-cols-4 gap-4">
  <aside class="md:col-span-1 bg-white border rounded-2xl shadow p-3 flex flex-col">
    <div class="flex items-center justify-between mb-2">
      <div class="font-semibold">Chats</div>
      <button id="newChat" class="inline-flex items-center gap-1 px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 rounded"><i data-lucide="plus"></i> New</button>
    </div>
    <div id="chats" class="flex-1 overflow-y-auto space-y-1 text-sm"></div>
  </aside>
  <section class="md:col-span-3 bg-white border rounded-2xl shadow flex flex-col">
    <div class="flex items-center justify-between p-3 border-b">
      <div id="chatTitle" class="font-medium">Select or start a chat</div>
      <div class="flex items-center gap-2">
        <span class="hidden sm:inline-flex items-center gap-1 text-xs px-2 py-0.5 rounded border border-gray-200 text-gray-700" title="Current AI provider">
          <i data-lucide="cpu"></i> {{ (ai_provider or 'none')|capitalize }}
        </span>
        <label class="flex items-center gap-1 text-xs text-gray-600">
          Model
          <select id="modelPick" class="border rounded px-1 py-0.5 text-xs">
            <option value="">Default</option>
            <option value="gemini-1.5-flash">gemini-1.5-flash</option>
            <option value="gemini-1.5-pro">gemini-1.5-pro</option>
          </select>
        </label>
        <label class="flex items-center gap-1 text-xs text-gray-600">
          <input id="streamToggle" type="checkbox" class="rounded" checked /> Stream
        </label>
        <button id="stopBtn" class="hidden inline-flex items-center gap-1 px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 border border-gray-200 rounded" title="Stop generating"><i data-lucide='square'></i> Stop</button>
        <button id="regenBtn" class="hidden inline-flex items-center gap-1 px-2 py-1 text-xs bg-gray-100 hover:bg-gray-200 border border-gray-200 rounded" title="Regenerate last answer"><i data-lucide='refresh-ccw'></i> Regenerate</button>
        <button id="deleteChat" class="hidden inline-flex items-center gap-1 px-2 py-1 text-xs bg-rose-50 text-rose-700 border border-rose-200 rounded"><i data-lucide='trash-2'></i> Delete</button>
      </div>
    </div>
    <div id="log" class="h-96 overflow-y-auto p-4 space-y-3 text-sm"></div>
    <div class="border-t p-3 flex items-center gap-2">
      <input id="msg" type="text" class="flex-1 border rounded-lg px-3 py-2 focus:outline-none focus:ring" placeholder="Type your question..." />
      <button id="send" class="btn-brand px-4 py-2 rounded-lg text-white">Send</button>
    </div>
  </section>
</div>

<div class="mt-3 text-xs text-gray-600 space-y-1">
  {% if not ai_configured %}
    <div>AI is in heuristic mode.</div>
  {% endif %}
  {% if kb_status %}
    <div>Knowledge base:
      <span>Project chunks: {{ kb_status.project_index.chunks }} {{ kb_status.project_index.available and '' or '(not built)' }}</span>
      â€¢
      <span>User chunks: {{ kb_status.user_index.chunks }} {{ kb_status.user_index.available and '' or '(none)' }}</span>
    </div>
    <div>Tip: enrich answers by building the index.</div>
    <div class="text-gray-500">Run: <code>python scripts/ai_index.py</code> for project docs. To add personal folders, run: <code>python scripts/ai_index_dirs.py --paths "C:\\MyDocs;D:\\Handbook"</code></div>
  {% endif %}
</div>

<script>
  const chatsEl = document.getElementById('chats');
  const log = document.getElementById('log');
  const msg = document.getElementById('msg');
  const send = document.getElementById('send');
  const newBtn = document.getElementById('newChat');
  const delBtn = document.getElementById('deleteChat');
  const chatTitle = document.getElementById('chatTitle');
  const streamToggle = document.getElementById('streamToggle');
  const modelPick = document.getElementById('modelPick');
  const stopBtn = document.getElementById('stopBtn');
  const regenBtn = document.getElementById('regenBtn');
  let currentChatId = null;
  let lastQuestion = null;
  let currentStream = null;
  let lastAssistantBubble = null;

  function add(role, text, asHtml=false) {
    const wrap = document.createElement('div');
    wrap.className = role === 'user' ? 'text-right' : 'text-left';
    const bubble = document.createElement('div');
    bubble.className = (role === 'user')
      ? 'inline-block bg-indigo-600 text-white rounded-lg px-3 py-2'
      : 'inline-block bg-gray-100 text-gray-800 rounded-lg px-3 py-2';
    if (asHtml) { bubble.innerHTML = text; } else { bubble.textContent = text; }
    wrap.appendChild(bubble);
    log.appendChild(wrap);
    log.scrollTop = log.scrollHeight;
    return bubble;
  }

  function renderChats(items){
    chatsEl.innerHTML = '';
    for (const c of (items||[])){
      const btn = document.createElement('button');
      btn.className = 'w-full text-left px-2 py-1 rounded hover:bg-gray-100 ' + (currentChatId===c.id? 'bg-gray-100' : '');
      btn.textContent = c.title || ('Chat #' + c.id);
      btn.onclick = () => selectChat(c.id, c.title);
      chatsEl.appendChild(btn);
    }
  }

  async function loadChats(){
    const r = await fetch('/ai/api/chats');
    const j = await r.json();
    if (j.ok) renderChats(j.chats);
  }

  async function selectChat(id, title){
    currentChatId = id; chatTitle.textContent = title || ('Chat #' + id);
    delBtn.classList.remove('hidden');
    regenBtn.classList.add('hidden');
    log.innerHTML = '';
    const r = await fetch('/ai/api/messages?chat_id=' + id);
    const j = await r.json();
    if (j.ok){
      for (const m of j.messages){ lastAssistantBubble = add(m.role, m.content); }
    }
    if (window.lucide) try{ lucide.createIcons(); }catch(e){}
  }

  function renderMarkdown(md){
    if (window.marked){ return window.marked.parse(md); }
    // Fallback: basic escaping
    const div = document.createElement('div');
    div.textContent = md; return div.innerHTML;
  }

  async function ask(q, opts={}) {
    lastQuestion = q;
    add('user', q);
    msg.value = '';
    if (streamToggle.checked){
      // Streaming via SSE
      const params = new URLSearchParams({ q });
      if (currentChatId) params.set('chat_id', String(currentChatId));
      const modelVal = (modelPick.value||'').trim(); if (modelVal) params.set('model', modelVal);
      if (opts.redo) params.set('redo', '1');
      if (currentStream) { try { currentStream.close(); } catch(_){} }
      const es = new EventSource('/ai/api/chat_stream?' + params.toString());
      currentStream = es;
      stopBtn.classList.remove('hidden');
      regenBtn.classList.add('hidden');
      // If replacing, remove last assistant bubble visually
      if (opts.replaceLast && lastAssistantBubble && lastAssistantBubble.parentElement){ lastAssistantBubble.parentElement.remove(); }
      let bubbleWrap = document.createElement('div');
      bubbleWrap.className = 'text-left';
      let bubble = document.createElement('div');
      bubble.className = 'inline-block bg-gray-100 text-gray-800 rounded-lg px-3 py-2 whitespace-pre-wrap';
      bubbleWrap.appendChild(bubble);
      log.appendChild(bubbleWrap);
      log.scrollTop = log.scrollHeight;
      es.addEventListener('meta', (ev) => {
        try {
          const meta = JSON.parse(ev.data||'{}');
          if (meta.chat_id && !currentChatId){ currentChatId = meta.chat_id; loadChats(); delBtn.classList.remove('hidden'); chatTitle.textContent = meta.title || 'Chat'; }
        } catch(_){}
      });
      es.onmessage = (ev) => {
        if (!ev.data) return;
        // Append raw delta, then render markdown once in a while
        bubble.textContent += ev.data;
        log.scrollTop = log.scrollHeight;
      };
      es.addEventListener('done', () => {
        // Final render with markdown
        const html = renderMarkdown(bubble.textContent);
        bubble.innerHTML = html;
        lastAssistantBubble = bubble;
        stopBtn.classList.add('hidden');
        regenBtn.classList.remove('hidden');
        es.close();
        currentStream = null;
      });
      // Graceful error handling: show message and try non-stream fallback once
      let triedFallback = false;
      es.addEventListener('error', async (ev) => {
        try { es.close(); } catch(_) {}
        currentStream = null;
        stopBtn.classList.add('hidden');
        regenBtn.classList.remove('hidden');
        const errText = (ev && ev.data) ? String(ev.data) : 'AI error. Please check your API key or model.';
        if (!bubble.textContent) bubble.textContent = errText;
        // Attempt one-shot fallback if we received nothing
        if (!triedFallback && !bubble.textContent.trim()){
          triedFallback = true;
          try {
            const body = { message:q, chat_id: currentChatId, model: (modelPick.value||'').trim() || undefined };
            const r2 = await fetch('/ai/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
            const j2 = await r2.json();
            if (j2 && (j2.answer||'').trim()){
              bubble.innerHTML = renderMarkdown(j2.answer);
            }
          } catch(_e) {}
        }
      });
    } else {
      try {
        const body = { message:q, chat_id: currentChatId, model: (modelPick.value||'').trim() || undefined, redo: !!opts.redo };
        const r = await fetch('/ai/api/chat', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        const j = await r.json();
        if (j.chat_id && !currentChatId){ currentChatId = j.chat_id; loadChats(); delBtn.classList.remove('hidden'); chatTitle.textContent = j.title || 'Chat'; }
        if (opts.replaceLast && lastAssistantBubble && lastAssistantBubble.parentElement){ lastAssistantBubble.parentElement.remove(); }
        lastAssistantBubble = add('assistant', renderMarkdown(j.answer || 'No answer'), true);
        regenBtn.classList.remove('hidden');
      } catch (e) { add('assistant', 'Error contacting AI.'); }
    }
  }

  newBtn.addEventListener('click', async () => {
    const provided = prompt('Chat title? (optional)') || undefined;
    const r = await fetch('/ai/api/new_chat', {method:'POST', headers:{'Content-Type': 'application/json'}, body: JSON.stringify({title: provided})});
    const j = await r.json();
    if (j.ok){ currentChatId = j.chat_id; await loadChats(); delBtn.classList.remove('hidden'); chatTitle.textContent = j.title || (provided || 'Chat'); log.innerHTML = ''; }
  });
  delBtn.addEventListener('click', async () => {
    if (!currentChatId) return;
    if (!confirm('Delete this chat?')) return;
    await fetch('/ai/api/chats/' + currentChatId, { method: 'DELETE' });
    currentChatId = null; chatTitle.textContent = 'Select or start a chat'; log.innerHTML = ''; delBtn.classList.add('hidden');
    await loadChats();
  });
  send.addEventListener('click', () => { if (msg.value.trim()) ask(msg.value.trim()); });
  msg.addEventListener('keydown', (e) => { if (e.key === 'Enter' && msg.value.trim()) ask(msg.value.trim()); });
  stopBtn.addEventListener('click', () => { if (currentStream) { try{ currentStream.close(); }catch(_){} currentStream = null; stopBtn.classList.add('hidden'); regenBtn.classList.remove('hidden'); } });
  regenBtn.addEventListener('click', () => { if (lastQuestion) ask(lastQuestion, { redo: true, replaceLast: true }); });
  if (window.lucide) try{ lucide.createIcons(); }catch(e){}
  loadChats();
</script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
{% endblock %}
